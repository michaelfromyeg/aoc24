# Auto-generated by Puzzles

import itertools
from dataclasses import dataclass


@dataclass
class Equation:
    target: int
    values: list[int]


def generate_op_permutations(n_ops, n_times):
    """
    Generate unique permutations of '+' and '*' operators using combinations.

    Args:
        n_ops: Total number of operators
        n_times: Number of '*' operators (remaining will be '+')
    """
    positions = range(n_ops)

    for times_positions in itertools.combinations(positions, n_times):
        result = ["+"] * n_ops

        for pos in times_positions:
            result[pos] = "*"

        yield tuple(result)


def myeval(equation: Equation, ops: list[str]):
    values = equation.values

    print("evaling", values, "with", ops)
    total = values[0]
    idx = 0

    while idx < len(ops):
        op = ops[idx]
        print("op", op, "value", values[idx + 1])
        if op == "+":
            total += values[idx + 1]
        else:
            total *= values[idx + 1]

        if total > equation.target:
            return -1
        idx += 1

    return total


def is_solvable(equation: Equation) -> bool:
    """
    How to check? We have 2^n possible combinations

    1. Brute force -- even writing this seems hard
    2. Higher or lower -- but switching from + to x isn't necessary bigger (e.g., + 1 vs. x 1)
    """
    n_ops = len(equation.values) - 1
    n_times = 0

    while n_times <= n_ops:
        # this was the old way, i used list(set(itertools.permutations(elements))
        # -- very slow!
        # elements = "+" * (n_ops - n_times) + "*" * n_times
        print("generating permutations with", n_ops, n_times)
        for permutation in list(generate_op_permutations(n_ops, n_times)):
            print("Trying", permutation, "on", equation.values)
            if (
                myeval(
                    equation,
                    permutation,
                )
                == equation.target
            ):
                return True
        n_times += 1

    return False


def solve():
    """
    Solution to the puzzle.
    """
    with open("day07/input.txt") as f:
        lines = f.readlines()

        equations: list[Equation] = []
        for line in lines:
            if not line.strip():
                continue

            target, values = line.strip().split(":")
            equation = Equation(
                target=int(target.strip()),
                values=[int(v.strip()) for v in values.strip().split(" ")],
            )
            equations.append(equation)

        # print(equations)

        total = 0
        for equation in equations:
            print("equation", equation)
            if is_solvable(equation):
                total += equation.target
        print(total)


def test_solve():
    """
    Test cases for the solution.
    """
    # TODO: Add test cases
    assert True, "Add your test cases here"


if __name__ == "__main__":
    test_solve()
    solve()
