"""
This is a total mess! But it works!
"""
# Auto-generated by Puzzles


def is_valid(edges: dict[int, set[int]], update: list[int]) -> bool:
    n = len(update)
    for i in range(0, n):
        for j in range(i, n):
            if update[i] in edges.get(update[j], set()):
                return False
    return True


def part_one(rules: list[tuple[int, int]], updates: list[list[int]]) -> int:
    """
    Validate each rule. Produce the middle-sum.

    For each val in update:
        is this val ok being after everything else in the list?
        (like a double loop)

        to edges[value after] == val fail

        we could construct smarter edges as we go?

        e.g., if 47 -> 53 and 53 -> 57, then 47 -> 57

        but n^2 doesn't seem to bad here
    """

    edges: dict[int, set[int]] = {}
    for rule in rules:
        if rule[0] in edges:
            edges[rule[0]].add(rule[1])
        else:
            edges[rule[0]] = set([rule[1]])

    total = 0
    valid_updates = 0
    for update in updates:
        if is_valid(edges, update):
            valid_updates += 1
            n = len(update)
            total += update[n // 2]

    print(f"{valid_updates=}")
    return total


def fix_update(edges: dict[int, set[int]], update: list[int]) -> list[int]:
    n = len(update)

    curr_update = [update[0]]
    for i in range(1, n):
        curr_update.append(update[i])
        before_set = edges.get(curr_update[i], set())
        # no rules apply; whatever
        if len(before_set) == 0:
            continue

        min_index = i + 1
        for value in before_set:
            if value not in curr_update:
                continue
            min_index = min(min_index, curr_update.index(value))
        if min_index >= i + 1:
            continue

        val = curr_update.pop()
        curr_update.insert(min_index, val)
    return curr_update


def part_two(rules: list[tuple[int, int]], updates: list[list[int]]) -> int:
    """
    Validate each rule. Produce the middle-sum.

    For each val in update:
        is this val ok being after everything else in the list?
        (like a double loop)

        to edges[value after] == val fail

        we could construct smarter edges as we go?

        47|53
        53 -> [47]
        e.g., if 47 -> 53 and 53 -> 57, then 47 -> 57

        but n^2 doesn't seem to bad here
    """

    edges: dict[int, set[int]] = {}
    for rule in rules:
        if rule[0] in edges:
            edges[rule[0]].add(rule[1])
        else:
            edges[rule[0]] = set([rule[1]])

    # this map is the opposite of the last one
    edges2: dict[int, set[int]] = {}
    for rule in rules:
        if rule[1] in edges2:
            edges2[rule[1]].add(rule[0])
        else:
            edges2[rule[1]] = set([rule[0]])

    total = 0
    invalid_updates = list(filter(lambda update: not is_valid(edges, update), updates))

    for update in invalid_updates:
        new_update = fix_update(edges2, update)
        total += new_update[len(new_update) // 2]

    print(f"{len(invalid_updates)=}")
    return total


def solve():
    """
    Solution to the puzzle.
    """
    with open("day05/input.txt") as f:
        lines = f.readlines()

        idx = 0
        n = len(lines)

        rules: list[tuple[int, int]] = []
        updates: list[list[int]] = []

        while lines[idx].strip() != "":
            l, r = lines[idx].strip().split("|")
            rules.append((int(l), int(r)))
            idx += 1
        idx += 1
        while idx < n:
            values = lines[idx].strip().split(",")
            updates.append([int(x) for x in values])
            idx += 1

        # print(rules)
        print(f"{len(updates)=}")

        total = part_one(rules, updates)
        total2 = part_two(rules, updates)

        print(total)
        print(total2)


# def test_solve():
#     """
#     Test cases for the solution.
#     """
#     # TODO: Add test cases
#     assert True, "Add your test cases here"


if __name__ == "__main__":
    # test_solve()
    solve()
